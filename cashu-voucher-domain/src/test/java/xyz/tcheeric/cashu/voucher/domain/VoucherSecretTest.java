package xyz.tcheeric.cashu.voucher.domain;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.*;

/**
 * Unit tests for {@link VoucherSecret}.
 *
 * <p>This test class verifies:
 * <ul>
 *   <li>Voucher creation with valid and invalid parameters</li>
 *   <li>Canonical CBOR serialization and determinism</li>
 *   <li>Expiry logic</li>
 *   <li>Immutability</li>
 *   <li>Equality and hashing</li>
 *   <li>Hex encoding/representation</li>
 * </ul>
 */
@DisplayName("VoucherSecret")
class VoucherSecretTest {

    private static final String ISSUER_ID = "merchant123";
    private static final String UNIT = "sat";
    private static final long FACE_VALUE = 10000L;
    private static final String MEMO = "Holiday gift card";

    @Nested
    @DisplayName("Creation")
    class Creation {

        @Test
        @DisplayName("should create voucher with auto-generated UUID")
        void shouldCreateVoucherWithAutoGeneratedUuid() {
            // When
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    null,
                    MEMO
            );

            // Then
            assertThat(voucher).isNotNull();
            assertThat(voucher.getVoucherId()).isNotBlank();
            assertThat(voucher.getIssuerId()).isEqualTo(ISSUER_ID);
            assertThat(voucher.getUnit()).isEqualTo(UNIT);
            assertThat(voucher.getFaceValue()).isEqualTo(FACE_VALUE);
            assertThat(voucher.getExpiresAt()).isNull();
            assertThat(voucher.getMemo()).isEqualTo(MEMO);
        }

        @Test
        @DisplayName("should create voucher with specified voucher ID")
        void shouldCreateVoucherWithSpecifiedVoucherId() {
            // Given
            String voucherId = "test-voucher-123";

            // When
            VoucherSecret voucher = VoucherSecret.create(
                    voucherId,
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    null,
                    MEMO
            );

            // Then
            assertThat(voucher.getVoucherId()).isEqualTo(voucherId);
        }

        @Test
        @DisplayName("should create voucher with expiry timestamp")
        void shouldCreateVoucherWithExpiryTimestamp() {
            // Given
            Long expiresAt = Instant.now().plusSeconds(86400).getEpochSecond();

            // When
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    expiresAt,
                    null
            );

            // Then
            assertThat(voucher.getExpiresAt()).isEqualTo(expiresAt);
            assertThat(voucher.isExpired()).isFalse();
            assertThat(voucher.isValid()).isTrue();
        }

        @Test
        @DisplayName("should create voucher without memo")
        void shouldCreateVoucherWithoutMemo() {
            // When
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    null,
                    null
            );

            // Then
            assertThat(voucher.getMemo()).isNull();
        }

        @Test
        @DisplayName("should reject zero face value")
        void shouldRejectZeroFaceValue() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    0L,
                    null,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Face value must be positive");
        }

        @Test
        @DisplayName("should reject negative face value")
        void shouldRejectNegativeFaceValue() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    -1000L,
                    null,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Face value must be positive");
        }

        @ParameterizedTest
        @ValueSource(strings = {"", " ", "   "})
        @DisplayName("should reject blank issuer ID")
        void shouldRejectBlankIssuerId(String blankIssuerId) {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    blankIssuerId,
                    UNIT,
                    FACE_VALUE,
                    null,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Issuer ID cannot be blank");
        }

        @ParameterizedTest
        @ValueSource(strings = {"", " ", "   "})
        @DisplayName("should reject blank unit")
        void shouldRejectBlankUnit(String blankUnit) {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID,
                    blankUnit,
                    FACE_VALUE,
                    null,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Unit cannot be blank");
        }

        @ParameterizedTest
        @ValueSource(strings = {"", " ", "   "})
        @DisplayName("should reject blank voucher ID")
        void shouldRejectBlankVoucherId(String blankVoucherId) {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    blankVoucherId,
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    null,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Voucher ID cannot be blank");
        }

        @Test
        @DisplayName("should reject zero expiry timestamp")
        void shouldRejectZeroExpiryTimestamp() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    0L,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Expiry timestamp must be positive");
        }

        @Test
        @DisplayName("should reject negative expiry timestamp")
        void shouldRejectNegativeExpiryTimestamp() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID,
                    UNIT,
                    FACE_VALUE,
                    -100L,
                    null
            ))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Expiry timestamp must be positive");
        }
    }

    @Nested
    @DisplayName("Serialization")
    class Serialization {

        @Test
        @DisplayName("should produce deterministic canonical bytes")
        void shouldProduceDeterministicCanonicalBytes() {
            // Given
            String voucherId = "fixed-id";
            VoucherSecret voucher1 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, MEMO);
            VoucherSecret voucher2 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, MEMO);

            // When
            byte[] bytes1 = voucher1.toCanonicalBytes();
            byte[] bytes2 = voucher2.toCanonicalBytes();

            // Then
            assertThat(bytes1).isEqualTo(bytes2);
        }

        @Test
        @DisplayName("should produce different bytes for different vouchers")
        void shouldProduceDifferentBytesForDifferentVouchers() {
            // Given
            VoucherSecret voucher1 = VoucherSecret.create("id1", ISSUER_ID, UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = VoucherSecret.create("id2", ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] bytes1 = voucher1.toCanonicalBytes();
            byte[] bytes2 = voucher2.toCanonicalBytes();

            // Then
            assertThat(bytes1).isNotEqualTo(bytes2);
        }

        @Test
        @DisplayName("should include expiry in canonical bytes when present")
        void shouldIncludeExpiryInCanonicalBytesWhenPresent() {
            // Given
            String voucherId = "test-id";
            Long expiresAt = 1700000000L;
            VoucherSecret withExpiry = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, null);
            VoucherSecret withoutExpiry = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] bytesWithExpiry = withExpiry.toCanonicalBytes();
            byte[] bytesWithoutExpiry = withoutExpiry.toCanonicalBytes();

            // Then
            assertThat(bytesWithExpiry).isNotEqualTo(bytesWithoutExpiry);
            assertThat(bytesWithExpiry.length).isGreaterThan(bytesWithoutExpiry.length);
        }

        @Test
        @DisplayName("should include memo in canonical bytes when present")
        void shouldIncludeMemoInCanonicalBytesWhenPresent() {
            // Given
            String voucherId = "test-id";
            VoucherSecret withMemo = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, "Test memo");
            VoucherSecret withoutMemo = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] bytesWithMemo = withMemo.toCanonicalBytes();
            byte[] bytesWithoutMemo = withoutMemo.toCanonicalBytes();

            // Then
            assertThat(bytesWithMemo).isNotEqualTo(bytesWithoutMemo);
            assertThat(bytesWithMemo.length).isGreaterThan(bytesWithoutMemo.length);
        }

        @Test
        @DisplayName("should produce valid hex string")
        void shouldProduceValidHexString() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            String hexString = voucher.toHexString();

            // Then
            assertThat(hexString).isNotBlank();
            assertThat(hexString).matches("^[0-9a-f]+$");
            assertThat(hexString.length() % 2).isEqualTo(0);
        }

        @Test
        @DisplayName("should return same bytes from toBytes() and toCanonicalBytes()")
        void shouldReturnSameBytesFromToBytesAndToCanonicalBytes() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] canonicalBytes = voucher.toCanonicalBytes();
            byte[] secretBytes = voucher.toBytes();
            byte[] dataBytes = voucher.getData();

            // Then
            assertThat(canonicalBytes).isEqualTo(secretBytes);
            assertThat(canonicalBytes).isEqualTo(dataBytes);
        }

        @Test
        @DisplayName("toString() should return hex string")
        void toStringShouldReturnHexString() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            String toString = voucher.toString();
            String toHex = voucher.toHexString();

            // Then
            assertThat(toString).isEqualTo(toHex);
        }
    }

    @Nested
    @DisplayName("Expiry")
    class Expiry {

        @Test
        @DisplayName("should report not expired when no expiry set")
        void shouldReportNotExpiredWhenNoExpirySet() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher.isExpired()).isFalse();
            assertThat(voucher.isValid()).isTrue();
        }

        @Test
        @DisplayName("should report not expired when expiry is in future")
        void shouldReportNotExpiredWhenExpiryIsInFuture() {
            // Given
            Long futureExpiry = Instant.now().plusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, futureExpiry, null);

            // When / Then
            assertThat(voucher.isExpired()).isFalse();
            assertThat(voucher.isValid()).isTrue();
        }

        @Test
        @DisplayName("should report expired when expiry is in past")
        void shouldReportExpiredWhenExpiryIsInPast() {
            // Given
            Long pastExpiry = Instant.now().minusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, pastExpiry, null);

            // When / Then
            assertThat(voucher.isExpired()).isTrue();
            assertThat(voucher.isValid()).isFalse();
        }
    }

    @Nested
    @DisplayName("Immutability")
    class Immutability {

        @Test
        @DisplayName("should reject setData() calls")
        void shouldRejectSetDataCalls() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);
            byte[] newData = new byte[]{1, 2, 3, 4};

            // When / Then
            assertThatThrownBy(() -> voucher.setData(newData))
                    .isInstanceOf(UnsupportedOperationException.class)
                    .hasMessageContaining("VoucherSecret is immutable");
        }

        @Test
        @DisplayName("should have final fields")
        void shouldHaveFinalFields() throws NoSuchFieldException {
            // Then - This is verified at compile time by Java's `final` keyword
            // If the fields weren't final, the code wouldn't compile
            assertThat(VoucherSecret.class.getDeclaredField("voucherId"))
                    .satisfies(field -> assertThat(java.lang.reflect.Modifier.isFinal(field.getModifiers())).isTrue());
        }
    }

    @Nested
    @DisplayName("Equality and Hashing")
    class EqualityAndHashing {

        @Test
        @DisplayName("should be equal when all fields match")
        void shouldBeEqualWhenAllFieldsMatch() {
            // Given
            String voucherId = "test-id";
            Long expiresAt = 1700000000L;
            VoucherSecret voucher1 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, MEMO);
            VoucherSecret voucher2 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, MEMO);

            // When / Then
            assertThat(voucher1).isEqualTo(voucher2);
            assertThat(voucher1.hashCode()).isEqualTo(voucher2.hashCode());
        }

        @Test
        @DisplayName("should not be equal when voucher ID differs")
        void shouldNotBeEqualWhenVoucherIdDiffers() {
            // Given
            VoucherSecret voucher1 = VoucherSecret.create("id1", ISSUER_ID, UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = VoucherSecret.create("id2", ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        @Test
        @DisplayName("should not be equal when issuer ID differs")
        void shouldNotBeEqualWhenIssuerIdDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = VoucherSecret.create(voucherId, "issuer1", UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = VoucherSecret.create(voucherId, "issuer2", UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        @Test
        @DisplayName("should not be equal when face value differs")
        void shouldNotBeEqualWhenFaceValueDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, 1000L, null, null);
            VoucherSecret voucher2 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, 2000L, null, null);

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        @Test
        @DisplayName("should be reflexive (equals itself)")
        void shouldBeReflexive() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher).isEqualTo(voucher);
        }

        @Test
        @DisplayName("should be symmetric")
        void shouldBeSymmetric() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher1.equals(voucher2)).isEqualTo(voucher2.equals(voucher1));
        }

        @Test
        @DisplayName("should not equal null")
        void shouldNotEqualNull() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher).isNotEqualTo(null);
        }

        @Test
        @DisplayName("should not equal different type")
        void shouldNotEqualDifferentType() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher).isNotEqualTo("not a voucher");
        }
    }

    @Nested
    @DisplayName("String Representations")
    class StringRepresentations {

        @Test
        @DisplayName("toStringWithMetadata() should include all fields")
        void toStringWithMetadataShouldIncludeAllFields() {
            // Given
            String voucherId = "test-voucher";
            Long expiresAt = Instant.now().plusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = VoucherSecret.create(voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, MEMO);

            // When
            String metadata = voucher.toStringWithMetadata();

            // Then
            assertThat(metadata).contains("voucherId='" + voucherId);
            assertThat(metadata).contains("issuerId='" + ISSUER_ID);
            assertThat(metadata).contains("unit='" + UNIT);
            assertThat(metadata).contains("faceValue=" + FACE_VALUE);
            assertThat(metadata).contains("expiresAt=" + expiresAt);
            assertThat(metadata).contains("memo='" + MEMO);
            assertThat(metadata).contains("valid");
        }

        @Test
        @DisplayName("toStringWithMetadata() should show EXPIRED status")
        void toStringWithMetadataShouldShowExpiredStatus() {
            // Given
            Long pastExpiry = Instant.now().minusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = VoucherSecret.create(ISSUER_ID, UNIT, FACE_VALUE, pastExpiry, null);

            // When
            String metadata = voucher.toStringWithMetadata();

            // Then
            assertThat(metadata).contains("EXPIRED");
        }
    }
}
