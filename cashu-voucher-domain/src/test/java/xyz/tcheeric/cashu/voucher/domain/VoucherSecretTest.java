package xyz.tcheeric.cashu.voucher.domain;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.time.Instant;
import java.util.Map;

import static org.assertj.core.api.Assertions.*;

/**
 * Unit tests for {@link VoucherSecret}.
 *
 * <p>This test class verifies:
 * <ul>
 *   <li>Voucher creation with valid and invalid parameters</li>
 *   <li>Canonical CBOR serialization and determinism</li>
 *   <li>Backing strategy support</li>
 *   <li>Merchant metadata handling</li>
 *   <li>Expiry logic</li>
 *   <li>Immutability</li>
 *   <li>Equality and hashing</li>
 *   <li>Hex encoding/representation</li>
 * </ul>
 */
@DisplayName("VoucherSecret")
class VoucherSecretTest {

    private static final String ISSUER_ID = "merchant123";
    private static final String UNIT = "EUR";
    private static final long FACE_VALUE = 1000L; // €10.00 in cents
    private static final String MEMO = "Holiday gift card";
    private static final BackingStrategy DEFAULT_STRATEGY = BackingStrategy.PROPORTIONAL;
    private static final double DEFAULT_ISSUANCE_RATIO = 0.01; // €0.01 per sat
    private static final int DEFAULT_FACE_DECIMALS = 2; // EUR has 2 decimal places

    /**
     * Helper method to create a voucher with default backing strategy parameters.
     */
    private VoucherSecret createVoucher(String issuerId, String unit, long faceValue,
                                        Long expiresAt, String memo) {
        return VoucherSecret.create(
                issuerId, unit, faceValue, expiresAt, memo,
                DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
        );
    }

    /**
     * Helper method to create a voucher with specified voucher ID and default backing strategy.
     */
    private VoucherSecret createVoucherWithId(String voucherId, String issuerId, String unit,
                                              long faceValue, Long expiresAt, String memo) {
        return VoucherSecret.create(
                voucherId, issuerId, unit, faceValue, expiresAt, memo,
                DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
        );
    }

    @Nested
    @DisplayName("Creation")
    class Creation {

        /**
         * Tests that a voucher can be created with auto-generated UUID and all required fields.
         */
        @Test
        @DisplayName("should create voucher with auto-generated UUID")
        void shouldCreateVoucherWithAutoGeneratedUuid() {
            // When
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, MEMO);

            // Then
            assertThat(voucher).isNotNull();
            assertThat(voucher.getVoucherId()).isNotBlank();
            assertThat(voucher.getIssuerId()).isEqualTo(ISSUER_ID);
            assertThat(voucher.getUnit()).isEqualTo(UNIT);
            assertThat(voucher.getFaceValue()).isEqualTo(FACE_VALUE);
            assertThat(voucher.getExpiresAt()).isNull();
            assertThat(voucher.getMemo()).isEqualTo(MEMO);
            assertThat(voucher.getBackingStrategy()).isEqualTo(DEFAULT_STRATEGY);
            assertThat(voucher.getIssuanceRatio()).isEqualTo(DEFAULT_ISSUANCE_RATIO);
            assertThat(voucher.getFaceDecimals()).isEqualTo(DEFAULT_FACE_DECIMALS);
        }

        /**
         * Tests that a voucher can be created with a specified voucher ID.
         */
        @Test
        @DisplayName("should create voucher with specified voucher ID")
        void shouldCreateVoucherWithSpecifiedVoucherId() {
            // Given
            String voucherId = "test-voucher-123";

            // When
            VoucherSecret voucher = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, MEMO);

            // Then
            assertThat(voucher.getVoucherId()).isEqualTo(voucherId);
        }

        /**
         * Tests that a voucher can be created with an expiry timestamp.
         */
        @Test
        @DisplayName("should create voucher with expiry timestamp")
        void shouldCreateVoucherWithExpiryTimestamp() {
            // Given
            Long expiresAt = Instant.now().plusSeconds(86400).getEpochSecond();

            // When
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, expiresAt, null);

            // Then
            assertThat(voucher.getExpiresAt()).isEqualTo(expiresAt);
            assertThat(voucher.isExpired()).isFalse();
            assertThat(voucher.isValid()).isTrue();
        }

        /**
         * Tests that a voucher can be created without a memo.
         */
        @Test
        @DisplayName("should create voucher without memo")
        void shouldCreateVoucherWithoutMemo() {
            // When
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // Then
            assertThat(voucher.getMemo()).isNull();
        }

        /**
         * Tests that zero face value is rejected.
         */
        @Test
        @DisplayName("should reject zero face value")
        void shouldRejectZeroFaceValue() {
            // When / Then
            assertThatThrownBy(() -> createVoucher(ISSUER_ID, UNIT, 0L, null, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Face value must be positive");
        }

        /**
         * Tests that negative face value is rejected.
         */
        @Test
        @DisplayName("should reject negative face value")
        void shouldRejectNegativeFaceValue() {
            // When / Then
            assertThatThrownBy(() -> createVoucher(ISSUER_ID, UNIT, -1000L, null, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Face value must be positive");
        }

        /**
         * Tests that blank issuer ID is rejected.
         */
        @ParameterizedTest
        @ValueSource(strings = {"", " ", "   "})
        @DisplayName("should reject blank issuer ID")
        void shouldRejectBlankIssuerId(String blankIssuerId) {
            // When / Then
            assertThatThrownBy(() -> createVoucher(blankIssuerId, UNIT, FACE_VALUE, null, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Issuer ID cannot be blank");
        }

        /**
         * Tests that blank unit is rejected.
         */
        @ParameterizedTest
        @ValueSource(strings = {"", " ", "   "})
        @DisplayName("should reject blank unit")
        void shouldRejectBlankUnit(String blankUnit) {
            // When / Then
            assertThatThrownBy(() -> createVoucher(ISSUER_ID, blankUnit, FACE_VALUE, null, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Unit cannot be blank");
        }

        /**
         * Tests that blank voucher ID is rejected.
         */
        @ParameterizedTest
        @ValueSource(strings = {"", " ", "   "})
        @DisplayName("should reject blank voucher ID")
        void shouldRejectBlankVoucherId(String blankVoucherId) {
            // When / Then
            assertThatThrownBy(() -> createVoucherWithId(blankVoucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Voucher ID cannot be blank");
        }

        /**
         * Tests that zero expiry timestamp is rejected.
         */
        @Test
        @DisplayName("should reject zero expiry timestamp")
        void shouldRejectZeroExpiryTimestamp() {
            // When / Then
            assertThatThrownBy(() -> createVoucher(ISSUER_ID, UNIT, FACE_VALUE, 0L, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Expiry timestamp must be positive");
        }

        /**
         * Tests that negative expiry timestamp is rejected.
         */
        @Test
        @DisplayName("should reject negative expiry timestamp")
        void shouldRejectNegativeExpiryTimestamp() {
            // When / Then
            assertThatThrownBy(() -> createVoucher(ISSUER_ID, UNIT, FACE_VALUE, -100L, null))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Expiry timestamp must be positive");
        }

        /**
         * Tests that zero issuance ratio is rejected.
         */
        @Test
        @DisplayName("should reject zero issuance ratio")
        void shouldRejectZeroIssuanceRatio() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, 0.0, DEFAULT_FACE_DECIMALS, null
            ))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Issuance ratio must be positive");
        }

        /**
         * Tests that negative issuance ratio is rejected.
         */
        @Test
        @DisplayName("should reject negative issuance ratio")
        void shouldRejectNegativeIssuanceRatio() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, -0.01, DEFAULT_FACE_DECIMALS, null
            ))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Issuance ratio must be positive");
        }

        /**
         * Tests that negative face decimals is rejected.
         */
        @Test
        @DisplayName("should reject negative face decimals")
        void shouldRejectNegativeFaceDecimals() {
            // When / Then
            assertThatThrownBy(() -> VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, -1, null
            ))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("Face decimals must be non-negative");
        }
    }

    @Nested
    @DisplayName("Backing Strategy")
    class BackingStrategyTests {

        /**
         * Tests that all backing strategies can be used when creating vouchers.
         */
        @Test
        @DisplayName("should support all backing strategies")
        void shouldSupportAllBackingStrategies() {
            for (BackingStrategy strategy : BackingStrategy.values()) {
                // When
                VoucherSecret voucher = VoucherSecret.create(
                        ISSUER_ID, UNIT, FACE_VALUE, null, null,
                        strategy, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
                );

                // Then
                assertThat(voucher.getBackingStrategy()).isEqualTo(strategy);
            }
        }

        /**
         * Tests that FIXED strategy vouchers are not splittable.
         */
        @Test
        @DisplayName("FIXED strategy should not be splittable")
        void fixedStrategyShouldNotBeSplittable() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.FIXED, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // When / Then
            assertThat(voucher.getBackingStrategy().isSplittable()).isFalse();
            assertThat(voucher.getBackingStrategy().hasFineGrainedSplits()).isFalse();
        }

        /**
         * Tests that MINIMAL strategy vouchers are splittable with coarse granularity.
         */
        @Test
        @DisplayName("MINIMAL strategy should be splittable with coarse granularity")
        void minimalStrategyShouldBeSplittableWithCoarseGranularity() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.MINIMAL, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // When / Then
            assertThat(voucher.getBackingStrategy().isSplittable()).isTrue();
            assertThat(voucher.getBackingStrategy().hasFineGrainedSplits()).isFalse();
        }

        /**
         * Tests that PROPORTIONAL strategy vouchers are splittable with fine granularity.
         */
        @Test
        @DisplayName("PROPORTIONAL strategy should be splittable with fine granularity")
        void proportionalStrategyShouldBeSplittableWithFineGranularity() {
            // Given
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.PROPORTIONAL, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // When / Then
            assertThat(voucher.getBackingStrategy().isSplittable()).isTrue();
            assertThat(voucher.getBackingStrategy().hasFineGrainedSplits()).isTrue();
        }
    }

    @Nested
    @DisplayName("Merchant Metadata")
    class MerchantMetadataTests {

        /**
         * Tests that merchant metadata can be included in a voucher.
         */
        @Test
        @DisplayName("should store merchant metadata")
        void shouldStoreMerchantMetadata() {
            // Given
            Map<String, Object> metadata = Map.of(
                    "passengerName", "John Doe",
                    "flightNumber", "LH1234",
                    "seat", "12A"
            );

            // When
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, metadata
            );

            // Then
            assertThat(voucher.getMerchantMetadata()).containsAllEntriesOf(metadata);
        }

        /**
         * Tests that merchant metadata is immutable after voucher creation.
         */
        @Test
        @DisplayName("should return immutable merchant metadata")
        void shouldReturnImmutableMerchantMetadata() {
            // Given
            Map<String, Object> metadata = Map.of("key", "value");
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, metadata
            );

            // When / Then
            assertThatThrownBy(() -> voucher.getMerchantMetadata().put("newKey", "newValue"))
                    .isInstanceOf(UnsupportedOperationException.class);
        }

        /**
         * Tests that null metadata results in empty map.
         */
        @Test
        @DisplayName("should handle null metadata as empty map")
        void shouldHandleNullMetadataAsEmptyMap() {
            // When
            VoucherSecret voucher = VoucherSecret.create(
                    ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // Then
            assertThat(voucher.getMerchantMetadata()).isEmpty();
        }

        /**
         * Tests that metadata is included in canonical bytes when present.
         */
        @Test
        @DisplayName("should include metadata in canonical bytes")
        void shouldIncludeMetadataInCanonicalBytes() {
            // Given
            String voucherId = "test-id";
            Map<String, Object> metadata = Map.of("key", "value");

            VoucherSecret withMetadata = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, metadata
            );
            VoucherSecret withoutMetadata = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // When
            byte[] bytesWithMetadata = withMetadata.toCanonicalBytes();
            byte[] bytesWithoutMetadata = withoutMetadata.toCanonicalBytes();

            // Then
            assertThat(bytesWithMetadata).isNotEqualTo(bytesWithoutMetadata);
            assertThat(bytesWithMetadata.length).isGreaterThan(bytesWithoutMetadata.length);
        }
    }

    @Nested
    @DisplayName("Builder")
    class BuilderTests {

        /**
         * Tests that the builder creates a valid voucher with all fields.
         */
        @Test
        @DisplayName("should create voucher using builder")
        void shouldCreateVoucherUsingBuilder() {
            // Given
            String voucherId = "builder-test";
            Long expiresAt = Instant.now().plusSeconds(3600).getEpochSecond();
            Map<String, Object> metadata = Map.of("event", "Concert");

            // When
            VoucherSecret voucher = VoucherSecret.builder()
                    .voucherId(voucherId)
                    .issuerId(ISSUER_ID)
                    .unit(UNIT)
                    .faceValue(FACE_VALUE)
                    .expiresAt(expiresAt)
                    .memo(MEMO)
                    .backingStrategy(BackingStrategy.FIXED)
                    .issuanceRatio(0.02)
                    .faceDecimals(2)
                    .merchantMetadata(metadata)
                    .build();

            // Then
            assertThat(voucher.getVoucherId()).isEqualTo(voucherId);
            assertThat(voucher.getIssuerId()).isEqualTo(ISSUER_ID);
            assertThat(voucher.getUnit()).isEqualTo(UNIT);
            assertThat(voucher.getFaceValue()).isEqualTo(FACE_VALUE);
            assertThat(voucher.getExpiresAt()).isEqualTo(expiresAt);
            assertThat(voucher.getMemo()).isEqualTo(MEMO);
            assertThat(voucher.getBackingStrategy()).isEqualTo(BackingStrategy.FIXED);
            assertThat(voucher.getIssuanceRatio()).isEqualTo(0.02);
            assertThat(voucher.getFaceDecimals()).isEqualTo(2);
            assertThat(voucher.getMerchantMetadata()).containsEntry("event", "Concert");
        }

        /**
         * Tests that the builder auto-generates UUID when not provided.
         */
        @Test
        @DisplayName("should auto-generate UUID when not provided")
        void shouldAutoGenerateUuidWhenNotProvided() {
            // When
            VoucherSecret voucher = VoucherSecret.builder()
                    .issuerId(ISSUER_ID)
                    .unit(UNIT)
                    .faceValue(FACE_VALUE)
                    .backingStrategy(DEFAULT_STRATEGY)
                    .issuanceRatio(DEFAULT_ISSUANCE_RATIO)
                    .faceDecimals(DEFAULT_FACE_DECIMALS)
                    .build();

            // Then
            assertThat(voucher.getVoucherId()).isNotBlank();
        }
    }

    @Nested
    @DisplayName("Serialization")
    class Serialization {

        /**
         * Tests that canonical bytes are deterministic for identical vouchers.
         */
        @Test
        @DisplayName("should produce deterministic canonical bytes")
        void shouldProduceDeterministicCanonicalBytes() {
            // Given
            String voucherId = "fixed-id";
            VoucherSecret voucher1 = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, MEMO);
            VoucherSecret voucher2 = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, MEMO);

            // When
            byte[] bytes1 = voucher1.toCanonicalBytes();
            byte[] bytes2 = voucher2.toCanonicalBytes();

            // Then
            assertThat(bytes1).isEqualTo(bytes2);
        }

        /**
         * Tests that different vouchers produce different canonical bytes.
         */
        @Test
        @DisplayName("should produce different bytes for different vouchers")
        void shouldProduceDifferentBytesForDifferentVouchers() {
            // Given
            VoucherSecret voucher1 = createVoucherWithId("id1", ISSUER_ID, UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = createVoucherWithId("id2", ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] bytes1 = voucher1.toCanonicalBytes();
            byte[] bytes2 = voucher2.toCanonicalBytes();

            // Then
            assertThat(bytes1).isNotEqualTo(bytes2);
        }

        /**
         * Tests that expiry is included in canonical bytes when present.
         */
        @Test
        @DisplayName("should include expiry in canonical bytes when present")
        void shouldIncludeExpiryInCanonicalBytesWhenPresent() {
            // Given
            String voucherId = "test-id";
            Long expiresAt = 1700000000L;
            VoucherSecret withExpiry = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, null);
            VoucherSecret withoutExpiry = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] bytesWithExpiry = withExpiry.toCanonicalBytes();
            byte[] bytesWithoutExpiry = withoutExpiry.toCanonicalBytes();

            // Then
            assertThat(bytesWithExpiry).isNotEqualTo(bytesWithoutExpiry);
            assertThat(bytesWithExpiry.length).isGreaterThan(bytesWithoutExpiry.length);
        }

        /**
         * Tests that memo is included in canonical bytes when present.
         */
        @Test
        @DisplayName("should include memo in canonical bytes when present")
        void shouldIncludeMemoInCanonicalBytesWhenPresent() {
            // Given
            String voucherId = "test-id";
            VoucherSecret withMemo = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, "Test memo");
            VoucherSecret withoutMemo = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] bytesWithMemo = withMemo.toCanonicalBytes();
            byte[] bytesWithoutMemo = withoutMemo.toCanonicalBytes();

            // Then
            assertThat(bytesWithMemo).isNotEqualTo(bytesWithoutMemo);
            assertThat(bytesWithMemo.length).isGreaterThan(bytesWithoutMemo.length);
        }

        /**
         * Tests that backing strategy is included in canonical bytes.
         */
        @Test
        @DisplayName("should include backing strategy in canonical bytes")
        void shouldIncludeBackingStrategyInCanonicalBytes() {
            // Given
            String voucherId = "test-id";
            VoucherSecret fixed = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.FIXED, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );
            VoucherSecret proportional = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.PROPORTIONAL, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // When
            byte[] fixedBytes = fixed.toCanonicalBytes();
            byte[] proportionalBytes = proportional.toCanonicalBytes();

            // Then
            assertThat(fixedBytes).isNotEqualTo(proportionalBytes);
        }

        /**
         * Tests that hex string output is valid.
         */
        @Test
        @DisplayName("should produce valid hex string")
        void shouldProduceValidHexString() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            String hexString = voucher.toHexString();

            // Then
            assertThat(hexString).isNotBlank();
            assertThat(hexString).matches("^[0-9a-f]+$");
            assertThat(hexString.length() % 2).isEqualTo(0);
        }

        /**
         * Tests that toBytes(), toCanonicalBytes(), and getData() return the same bytes.
         */
        @Test
        @DisplayName("should return same bytes from toBytes() and toCanonicalBytes()")
        void shouldReturnSameBytesFromToBytesAndToCanonicalBytes() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            byte[] canonicalBytes = voucher.toCanonicalBytes();
            byte[] secretBytes = voucher.toBytes();
            byte[] dataBytes = voucher.getData();

            // Then
            assertThat(canonicalBytes).isEqualTo(secretBytes);
            assertThat(canonicalBytes).isEqualTo(dataBytes);
        }

        /**
         * Tests that toString() returns the hex string representation.
         */
        @Test
        @DisplayName("toString() should return hex string")
        void toStringShouldReturnHexString() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            String toString = voucher.toString();
            String toHex = voucher.toHexString();

            // Then
            assertThat(toString).isEqualTo(toHex);
        }
    }

    @Nested
    @DisplayName("Expiry")
    class Expiry {

        /**
         * Tests that voucher with no expiry is not expired.
         */
        @Test
        @DisplayName("should report not expired when no expiry set")
        void shouldReportNotExpiredWhenNoExpirySet() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher.isExpired()).isFalse();
            assertThat(voucher.isValid()).isTrue();
        }

        /**
         * Tests that voucher with future expiry is not expired.
         */
        @Test
        @DisplayName("should report not expired when expiry is in future")
        void shouldReportNotExpiredWhenExpiryIsInFuture() {
            // Given
            Long futureExpiry = Instant.now().plusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, futureExpiry, null);

            // When / Then
            assertThat(voucher.isExpired()).isFalse();
            assertThat(voucher.isValid()).isTrue();
        }

        /**
         * Tests that voucher with past expiry is expired.
         */
        @Test
        @DisplayName("should report expired when expiry is in past")
        void shouldReportExpiredWhenExpiryIsInPast() {
            // Given
            Long pastExpiry = Instant.now().minusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, pastExpiry, null);

            // When / Then
            assertThat(voucher.isExpired()).isTrue();
            assertThat(voucher.isValid()).isFalse();
        }
    }

    @Nested
    @DisplayName("Immutability")
    class Immutability {

        /**
         * Tests that setData() is rejected for immutability.
         */
        @Test
        @DisplayName("should reject setData() calls")
        void shouldRejectSetDataCalls() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);
            byte[] newData = new byte[]{1, 2, 3, 4};

            // When / Then
            assertThatThrownBy(() -> voucher.setData(newData))
                    .isInstanceOf(UnsupportedOperationException.class)
                    .hasMessageContaining("VoucherSecret is immutable");
        }

        /**
         * Tests that fields are final (verified at compile time, this test documents the intent).
         */
        @Test
        @DisplayName("should have final fields")
        void shouldHaveFinalFields() throws NoSuchFieldException {
            // Then - This is verified at compile time by Java's `final` keyword
            assertThat(VoucherSecret.class.getDeclaredField("voucherId"))
                    .satisfies(field -> assertThat(java.lang.reflect.Modifier.isFinal(field.getModifiers())).isTrue());
            assertThat(VoucherSecret.class.getDeclaredField("backingStrategy"))
                    .satisfies(field -> assertThat(java.lang.reflect.Modifier.isFinal(field.getModifiers())).isTrue());
        }
    }

    @Nested
    @DisplayName("Equality and Hashing")
    class EqualityAndHashing {

        /**
         * Tests that two vouchers with identical fields are equal.
         */
        @Test
        @DisplayName("should be equal when all fields match")
        void shouldBeEqualWhenAllFieldsMatch() {
            // Given
            String voucherId = "test-id";
            Long expiresAt = 1700000000L;
            Map<String, Object> metadata = Map.of("key", "value");

            VoucherSecret voucher1 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, MEMO,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, metadata
            );
            VoucherSecret voucher2 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, MEMO,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, metadata
            );

            // When / Then
            assertThat(voucher1).isEqualTo(voucher2);
            assertThat(voucher1.hashCode()).isEqualTo(voucher2.hashCode());
        }

        /**
         * Tests that vouchers with different voucher IDs are not equal.
         */
        @Test
        @DisplayName("should not be equal when voucher ID differs")
        void shouldNotBeEqualWhenVoucherIdDiffers() {
            // Given
            VoucherSecret voucher1 = createVoucherWithId("id1", ISSUER_ID, UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = createVoucherWithId("id2", ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        /**
         * Tests that vouchers with different issuer IDs are not equal.
         */
        @Test
        @DisplayName("should not be equal when issuer ID differs")
        void shouldNotBeEqualWhenIssuerIdDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = createVoucherWithId(voucherId, "issuer1", UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = createVoucherWithId(voucherId, "issuer2", UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        /**
         * Tests that vouchers with different face values are not equal.
         */
        @Test
        @DisplayName("should not be equal when face value differs")
        void shouldNotBeEqualWhenFaceValueDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = createVoucherWithId(voucherId, ISSUER_ID, UNIT, 1000L, null, null);
            VoucherSecret voucher2 = createVoucherWithId(voucherId, ISSUER_ID, UNIT, 2000L, null, null);

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        /**
         * Tests that vouchers with different backing strategies are not equal.
         */
        @Test
        @DisplayName("should not be equal when backing strategy differs")
        void shouldNotBeEqualWhenBackingStrategyDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.FIXED, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );
            VoucherSecret voucher2 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    BackingStrategy.PROPORTIONAL, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, null
            );

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        /**
         * Tests that vouchers with different issuance ratios are not equal.
         */
        @Test
        @DisplayName("should not be equal when issuance ratio differs")
        void shouldNotBeEqualWhenIssuanceRatioDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, 0.01, DEFAULT_FACE_DECIMALS, null
            );
            VoucherSecret voucher2 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, 0.02, DEFAULT_FACE_DECIMALS, null
            );

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        /**
         * Tests that vouchers with different merchant metadata are not equal.
         */
        @Test
        @DisplayName("should not be equal when merchant metadata differs")
        void shouldNotBeEqualWhenMerchantMetadataDiffers() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, Map.of("key", "value1")
            );
            VoucherSecret voucher2 = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null,
                    DEFAULT_STRATEGY, DEFAULT_ISSUANCE_RATIO, DEFAULT_FACE_DECIMALS, Map.of("key", "value2")
            );

            // When / Then
            assertThat(voucher1).isNotEqualTo(voucher2);
        }

        /**
         * Tests that equals is reflexive.
         */
        @Test
        @DisplayName("should be reflexive (equals itself)")
        void shouldBeReflexive() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher).isEqualTo(voucher);
        }

        /**
         * Tests that equals is symmetric.
         */
        @Test
        @DisplayName("should be symmetric")
        void shouldBeSymmetric() {
            // Given
            String voucherId = "test-id";
            VoucherSecret voucher1 = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);
            VoucherSecret voucher2 = createVoucherWithId(voucherId, ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher1.equals(voucher2)).isEqualTo(voucher2.equals(voucher1));
        }

        /**
         * Tests that voucher does not equal null.
         */
        @Test
        @DisplayName("should not equal null")
        void shouldNotEqualNull() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher).isNotEqualTo(null);
        }

        /**
         * Tests that voucher does not equal different type.
         */
        @Test
        @DisplayName("should not equal different type")
        void shouldNotEqualDifferentType() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When / Then
            assertThat(voucher).isNotEqualTo("not a voucher");
        }
    }

    @Nested
    @DisplayName("String Representations")
    class StringRepresentations {

        /**
         * Tests that toStringWithMetadata() includes all fields including new backing strategy fields.
         */
        @Test
        @DisplayName("toStringWithMetadata() should include all fields")
        void toStringWithMetadataShouldIncludeAllFields() {
            // Given
            String voucherId = "test-voucher";
            Long expiresAt = Instant.now().plusSeconds(3600).getEpochSecond();
            Map<String, Object> metadata = Map.of("event", "Concert");

            VoucherSecret voucher = VoucherSecret.create(
                    voucherId, ISSUER_ID, UNIT, FACE_VALUE, expiresAt, MEMO,
                    BackingStrategy.PROPORTIONAL, 0.01, 2, metadata
            );

            // When
            String metadataStr = voucher.toStringWithMetadata();

            // Then
            assertThat(metadataStr).contains("voucherId='" + voucherId);
            assertThat(metadataStr).contains("issuerId='" + ISSUER_ID);
            assertThat(metadataStr).contains("unit='" + UNIT);
            assertThat(metadataStr).contains("faceValue=" + FACE_VALUE);
            assertThat(metadataStr).contains("faceDecimals=2");
            assertThat(metadataStr).contains("backingStrategy=PROPORTIONAL");
            assertThat(metadataStr).contains("issuanceRatio=0.01");
            assertThat(metadataStr).contains("expiresAt=" + expiresAt);
            assertThat(metadataStr).contains("memo='" + MEMO);
            assertThat(metadataStr).contains("merchantMetadata=");
            assertThat(metadataStr).contains("valid");
        }

        /**
         * Tests that toStringWithMetadata() shows EXPIRED status for expired vouchers.
         */
        @Test
        @DisplayName("toStringWithMetadata() should show EXPIRED status")
        void toStringWithMetadataShouldShowExpiredStatus() {
            // Given
            Long pastExpiry = Instant.now().minusSeconds(3600).getEpochSecond();
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, pastExpiry, null);

            // When
            String metadata = voucher.toStringWithMetadata();

            // Then
            assertThat(metadata).contains("EXPIRED");
        }

        /**
         * Tests that toStringWithMetadata() omits metadata when empty.
         */
        @Test
        @DisplayName("toStringWithMetadata() should omit metadata when empty")
        void toStringWithMetadataShouldOmitMetadataWhenEmpty() {
            // Given
            VoucherSecret voucher = createVoucher(ISSUER_ID, UNIT, FACE_VALUE, null, null);

            // When
            String metadata = voucher.toStringWithMetadata();

            // Then
            assertThat(metadata).doesNotContain("merchantMetadata=");
        }
    }
}
